## adv3

### 람다가 필요한 이유
- 동작 매개변수화
  - 값 뿐만 아니라 코드 조각(동작, 로직) 자체를 매개변수로 전달하여, 메서드 동작을 변경
  - 람다 -> 이를 기존 방식보다 훨씬 간결하게 표현할 수 있도록 해준다
  - 함수와 메서드는 수행하는 역할 자체는 같지만, 소속(클래스 or 독립)과 호출 방식에서 차이가 난다고 이해하면 된다

### 람다 (익명 함수)
- 내부 동작 : new 키워드를 사용하지 않지만, 람다도 익명 클래스처럼 내부적으로 클래스가 만들어지고 인스턴스가 생성 (문법 설탕)
- 메서드 시그니처가 일치해야 사용 가능하다. (매개변수 이름은 상관 X)
- 함수
  - 일반적인 함수 -> 데이터(값)을 입력으로 받고 반환
  - 고차 함수 -> 함수를 인자로 받거나 반환

### 함수형 인터페이스
- 하나의 추상메서드 만을 가지는 인터페이스, 람다 활당 규칙
- 의도를 명시적으로 드러내는 함수형 인터페이스 쓰자 (특화 함수형 인터페이스를 씀으로써 의도 명확히)
- 기본형 지원 함수형 인터페이스
  - 오토박싱/언박싱 성능 비용 개선
  - 제네릭 한계 (기본형 다룰 수 없음) 극복
- 자바가 제공하는 기본 함수형 인터페이스 쓰자
- 람다와 타겟 타입
  - 람다 표현식은 그 자체만으로는 구체적인 타입을 가지지 않는다
  - 람다가 대입되는 함수형 인터페이스의 참조 변수를 '타겟 타입'이라고 한다
  - 메소드 시그니쳐가 같은 함수형 인터페이스라도 한번 결정된 후 타입이 다르면 상호 대입X

### 람다 vs 익명 클래스
- 상속 관계
  - 익명 클래스는 일반적인 클래스 처럼 다양한 인터페이스와 클래스 구현, 상속 가능
  - 람다는 함수형 인터페이스 만을 구현 가능, 상태(필드, 멤버 변수)나 추가적인 메서드 오버라이딩은 불가능
- this
  - 익명 클래스 내부에서 this 는 익명 클래스 자신
  - 람다 내부의 this 는 람다가 선언된 외부 클래스의 this 와 동일 (별도의 컨텍스트 x)
- 생성 방식
  - 익명 클래스 -> 컴파일 시 실제 클래스 파일 생성, 일반적인 클래스와 같은 방식
  - 람다 -> invokeDynamic 이라는 메커니즘을 사용
    - 컴파일 타임에 실제 클래스 파일을 생성하지 않고, 런타임 시점에서 동적으로 필요한 코드를 처리
- 상태
  - 함수인 람다는 기본적으로 필드(멤버 변수)가 없으므로 스스로 상태를 유지X

### 메서드 참조 `lambda.methodref 패키지`
- 이미 정의된 메서드를 그대로 참조하여 람다 표현식을 더 간결하게 작성
- 메서드 참조에서 ()를 사용하지 않는 이유 -> 메서드 참조를 하는 시점에는 메서드를 호출X 단순히 메서드의 이름으로 해당 메서드를 참조만 한다
  1. 정적 메서드 참조
  2. 특정 객체의 인스턴스 메서드 참조
  3. 생성자 참조
  4. 임의 객체의 인스턴스 메서드 참조

### 스트림 `stream 패키지`
- 필터와 맵을 포함한 여러 연산을 연속해서 적용하기 위해, 이를 하나의 흐름(스트림)으로 표현
- 선언형 프로그래밍, 메서드 체인, 정적 팩토리 메서드, 내부 반복 사용
- 데이터 소스 변경 x, 일회성, 파이프라인, 지연연산, 병렬 처리 용이 (주의 해야 한다)
- 단축 평가가 되는 이유에 대해서 생각해보자 `ShortCircuit 클래스`
- 스트림 생성 -> 유한 스트림/무한 스트림
- 중간 연산
  - flatMap : 중첩 구조 (컬렉션 안의 컬렉션, 배열 안의 배열 등) 일차원으로 펼치는 데 사용
- 최종 연산
  - Optional 이 필요한 연산인지 아닌지 왜그런지 생각해보자
- 기본형 특화 스트림
  - 성능 : for문 > 기본형 특화 스트림 (IntStream 등) > 일반 스트림 이지만, 극단적인 경우를 제외하곤 성능 차이 크게 없음
  - 가독성에 더 신경쓰자
    - 아주 간단한 반복이거나, 중간에 break, continue 가 들어가는 흐름 제어가 필요한 경우는 외부 반복이 더 간결하고 빠르게 이해될 수 있다
- 컬렉터
  - groupingBy(...)는 특정 기준에 따라 스트림 요소를 여러 그룹으로
  - partitioningBy(...)는 단순하게 true 와 false 두 그룹으로
  - 최대/최소, 통계, 리듀싱
- 다운 스트림 컬렉터 
  - 그룹별 개수를 세거나, 평균을 구하거나, 특정 필드를 뽑아서 맵핑하거나 등등의 작업이 필요하다면, 적절한 다운 스트림 컬렉터를 추가로 지정
  - mapping() : 그룹화(또는 분할)된 각 그룹 내의 개별 요소들을 다른 값으로 변환(mapping)한 뒤, 그 변환된 값 들을 다시 다른 Collector로 수집할 수 있게 해준다
  - collectingAndThen() : 다운 스트림 컬렉터가 최종 결과를 만든 뒤에 한 번 더 후처리할 수 있도록 해준다. 즉, "1차 Collector → 후처리 함수" 순서로 작업

### Optional `optinal 패키지`
- 값이 없을 수 있따는 상황을 명시적으로
- 항상 값이 있어야 하는 상황에는 그냥 해당 타입을 바로 사용하거나 예외를 던지는 방식이 더 좋을 수 있다
- orElse(), orElseGet() 차이 (즉시평가, 지연평가)
  - 자바애선 매개 변수에 계산 내용이 있다면 먼저 계산되게 된다
  - 람다 사용하면 코드 조각만 보내고 호출 시점 미룰 수 있다
  - 계산 내용 생성 비용이 크다면, orElseGet을 사용해서 먼저 값이 존재하는지 판단하게 한 후, 값이 존재하지 않는다면 계산하도록 할 수 있다
  - 계산 내용 생성 비용이 크지 않다면 단순 orElse를 선택해도 괜찮다
- Optional.filter(predicate) vs Stream.filter(predicate)
  - Optional.filter(predicate) 에 Optional.empty()가 전달 되었다면, predicate에서 사용되더라도 npe가 발생하지 않는다. 아예 실행되지 않는다
  - Stream.filter(predicate) 는 각 요소에 대해 실행하여, null요소가 포함되어 있다면, npe가 발생 가능성 있다 (체크 해줘야 함)
- 베스트 프랙티스
  - 반환 타입으로만 사용하고, 필드에는 가급적 X
  - 메서드 매개변수로 Optional 을 사용 X
  - 컬렉션(Collection)이나 배열 타입을 Optional 로 감싸지 말기 -> 빈 컬렉션 사용
  - isPresent() 와 get() 조합을 직접 사용 X
  - 무조건 값이 있다고 판단되거나, 값이 없으면 예외를 던지거나 하는 것이 더 자연스러운 경우 아예 사용하지 않는 것이 더 좋을 수 있다
  - **클라이언트 입장**에서 코드를 작성하자

### 디폴트 메서드
- 디폴트 메서드 도입 이유
  - 하휘 호환성, 라이브러리 확장성, 설계 유연성
- 디폴트 메서드 주의점
  - 최소한으로 사용 -> 자칫 다이아몬드 문제 발생시킴. 인터페이스는 계약의 역할에 충실하는 것이 좋다
  - 상태를 두지 않기 -> 필요하다면 클래스로 옮기자

### Fork/Join `parallel.forkjoin 패키지`
- 패턴의 3단계 
  - 분할 (Fork) : 하나의 큰 작업을 여러 스레드가 처리할 수 있도록 작은 단위로 나눔
  - 처리 (Execute) : 분할된 작업을 각 스레드가 병렬로 처리
  - 병합 (Join) : 각 스레드에서 처리된 결과를 하나로 합쳐 최종 결과를 만든다 
- 주요 개념
  - 분할 정복 (Divide and Conquer) : 큰 작업을 재귀적으로 작은 단위로 분할하고, 각 결과를 합쳐 최종 결과물을 생성하는 전략 
  - 작업 훔치기 (Work Stealing)
    - Fork/Join 풀의 핵심 알고리즘으로, 각 스레드는 자신만의 작업 큐(Queue)를 가진다.
    - 할 일이 없는 스레드는 다른 바쁜 스레드의 큐에서 작업을 "훔쳐와" 처리함으로써, 스레드들이 쉬지 않고 일하게 하여 시스템 효율성을 극대화
    - 적절한 작업 크기 선택 -> 작업의 복잡성, 균일성, 시스템 하드웨어 등 고려 -> 보통 스레드 수의 4~10배, 참고로만 알자
- Fork/Join 공용 풀
  - 애플리케이션 내에서 단일 인스턴스로 공유되어 사용
  - 별도로 생성하지 않아도 생성됨, ForkJoinPool.commonPool() 을 통해 접근 가능
  - 기본적으로 시스템의 가용 프로세서 수에서 1을 뺀 값으로 병렬 수준(parallelism)이 설정
  - 공용 풀 vs 커스텀 풀
    - 커스텀 풀은 명시적으로 생성하고 관리해야 하지만, 공용 풀은 시스템에서 자동으로 관리 (jvm이 자동으로 종료)

### 병렬 스트림 `parallel 패키지`
- 직접 스레드를 만들 필요 없이 기존 스트림에 parallel() 메서드만 호출하면, 스트림이 자동으로 병렬 처리
  - .parallel()을 호출하면 스트림 연산은 내부적으로 Fork/Join 공용 풀(Common Pool)을 사용 
  - 개발자가 복잡한 멀티스레드 코드를 작성할 필요 없이, 데이터 분할(Fork), 처리(Execute), 결과 병합(Join) 과정이 자동으로 처리
- 실무에서 공용 풀은 **절대** I/O 바운드 작업을 하면 안된다
  - 공용 풀 병목 현상: 모든 병렬 스트림이 동일한 공용 풀을 공유하므로, 요청이 많아질수록 병목 현상이 발생
  - 자원 경쟁: 여러 요청이 제한된 스레드 풀을 두고 경쟁하면서 요청의 성능이 저하된다.
  - 예측 불가능한 성능: 같은 작업이라도 동시에 실행되는 다른 작업의 수에 따라 처리 시간이 크게 달라진다
- 공용 풀은 반드시 CPU 바운드(계산 집약적인) 작업에만 사용해야 한다
  - 공용 풀은 애초에 cpu작업에 적합하도록 최적화 되어 있다는 것을 기억하자
  - 백엔드 개발자 로서 사실 잘 다룰 일이 없다
- 실무에서 자주 하는 실수가 병렬 스트림을 I/O 대기 작업에 사용하거나, 또는 CompletableFuture 를 사용할 때 발생
  - 실무에서 복잡한 멀티스레드 코드를 작성할 때는 CompletableFuture 가 도움이 된다 (나중에 사용하게 될 때 학습하면 충분)
  - CompletableFuture 를 생성할 때는 별도의 스레드 풀을 반드시 지정해야 한다. 공용 풀이 대신 사용된다. 
  - **CompletableFuture 를 사용할 때는 반드시! 커스텀 풀을 지정해서 사용하자**

### 함수형 프로그래밍 `functional 패키지`
  - 자바 함수형 프로그래밍 특징
  - 순수 함수(Pure Function)
  - 부수 효과(Side Effect) 최소화
  - 불변성(Immutable State) 지향 
  - 일급 시민(First-class Citizen) 함수 
  - 선언형(Declarative) 접근 
  - 함수 합성(Composition)
  - Lazy Evaluation(지연 평가) (선택적 특징)