#### 1단계: 스레드 생성 (NEW 상태)
- new Thread()로 스레드 객체만 생성된 상태
- 아직 start() 호출 전
- JVM 내부 객체만 존재하고, OS 커널 스레드는 생성되지 않음

#### 2단계: start() 호출 → 커널 스레드 생성
- start() 메서드 호출 시:
    - JVM이 JNI를 통해 시스템 콜 수행
    - OS 커널이 새로운 커널 스레드 생성
    - 자바 스레드와 커널 스레드가 1:1 매핑됨
- 자바 스레드는 NEW → RUNNABLE 상태로 전환

#### 3단계: 스케줄링 큐 진입 (RUNNABLE 상태)
- 커널 스레드는 OS의 레디 큐(스케줄링 큐)에 진입
- 자바 스레드는 RUNNABLE 상태지만 아직 CPU를 점유하지 않음
- OS 스케줄러의 CPU 할당을 기다림

#### 4단계: CPU 점유 획득 → 실행 시작
- OS 스케줄러가 해당 스레드에 CPU를 할당하면:
    - 스레드가 실제로 실행됨
    - JVM이 해당 스레드의 run() 메서드를 호출
- 자바 관점에서는 여전히 RUNNABLE 상태

#### 5단계: synchronized 블록 진입 시도 → 락 획득 대기
- synchronized 블록에 진입할 경우:
    - 락이 비어 있으면 즉시 진입
    - 락이 점유 중이면 BLOCKED 상태로 전환
    - JVM의 락 대기 집합(Lock Wait Set)에 등록됨

#### 6단계: 락 획득 실패 → BLOCKED 상태
- 다른 스레드가 락을 점유하고 있는 동안:
    - 현재 스레드는 BLOCKED 상태 유지
    - 운영체제 수준에서 스케줄링에서 제외됨 (자원 소비 없음)
    - 스레드는 **레디 큐에는 없지만**, 커널 수준에서 여전히 존재함
    - 운영체제는 해당 스레드의 대기 상태를 추적하고 있음

#### 7단계: 락 해제, 획득시도, 성공. BLOCKED→RUNNABLE 전환
- 임계 영역을 점유 중이던 다른 스레드가 synchronized 블록을 빠져나가며 락을 해제
- JVM은 락 대기집합(lock wait set)에 있던 BLOCKED 스레드 중 하나를 선택해
    - 락 획득
    - 운영체제 스케줄링 큐(Ready Queue)에 삽입

#### 8단계: RUNNABLE 상태에서 임계 영역 진입
- 조건: 운영체제가 스케줄링하여 CPU 할당
    - 임계 영역 로직(생산자·소비자 검사 등) 수행

#### 9단계: 생산자·소비자 문제로 인한 락 양도
- object.wait() 호출 → 현재 스레드가 락을 반납
- JVM의 **스레드 대기집합(thread wait set)**으로 이동 → WAITING 상태
- 운영체제 스케줄링 큐에서 제거, CPU 점유 완전 상실

#### 10단계: notify()/notifyAll()로 WAITING→BLOCKED 전환
- 다른 스레드가 object.notify() 또는 notifyAll() 호출
- JVM은 waiting set에서 하나(또는 전부)를 깨워서
- 락 대기집합 으로 이동 → BLOCKED 상태
- CPU는 여전히 점유하지 못함

#### 11단계: 락 획득 시도, 성공
- 7~8단계 수행

#### 12단계: 종료
- 생산자·소비자 조건 재확인
- 작업 완료 시 synchronized 블록 종료 → 락 해제
- run() 메서드 종료 → TERMINATED 상태
- JVM이 스레드 정리, OS가 커널 스레드 자원 회수