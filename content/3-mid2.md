## [mid2](https://github.com/aammddkkzxc/java-practice/tree/master/code/mid2/src)
- 제네릭, 컬렉션, 순회, 정렬

#### 제네릭
- 다양한 타입에 대해 동작하는 코드가 필요할 때 유용
- 제네릭 타입
  - 클래스의 타입을 객체 생성시점에 결정짓도록 한다
  - 타입 안전성, 코드 재사용성 해결
  - 타입 매개변수 상한을 사용해서 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용
- 제네릭 메소드
  - 메소드에 따로 타임 파라미터를 명시해 줘야 한다
  - 제네릭 타입과 제네릭 메서드의 타입 파라미터 ex) T 를 겹치도록 하지 않도록 설정하자
    - 혹시 겹친다면 제네릭 메서드의 타입 매개변수가 더 높은 우선순위를 가진다 (애초에 이렇게 사용하지 않는 것을 권장)
- 와일드 카드
  - 와일드카드는 제네릭 타입이나, 제네릭 메서드를 선언하는 것이 아니다. 와일드카드는 이미 만들어진 제네릭 타입을 활용할 때 사용
  - 제네릭 타입이나 제네릭 메서드를 정의하는게 꼭 필요한 상황이 아니라면, 더 단순한 와일드카드 사용을 권장
  - 제네릭 메서드 -> 전달한 타입 명확하게 반환 가능
  - 와일드 카드 -> 상한으로 설정한 타입으로 반환 가능 (싫으면 타입 캐스팅 직접 해야함)
- 타입 이레이저
  - 제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다.
  - java 에는 제네릭의 타입 매개변수가 존재하지만, 컴파일 이후인 자바 바이트코드 .class 에는 타입 매개변수가 존재하지 않음
  - 런타임에 타입 파라미터가 Objcet/상한제한 클래스로 변경. -> instanceof 가 항상 참, 항상 new Object가 되는현상 발생 -> 둘다 사용 불가

#### 컬렉션
- ArrayList
  - 데이터를 담는 배열 타입을 Object로 사용하는 이유와 그렇게 해도 문제가 없는 이유에 대해서 생각해 보자 (호환성, 타입 이레이저, 캐스팅)
- 시간 복잡도와 실제 성능 
  - 이론적으로 LinkedList 의 중간 삽입 연산은 ArrayList 보다 빠를 수 있다. 그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다. 
    - 추가로 ArrayList 는 데이터를 한 칸씩 직접 이동하지 않고, 대신에 메모리 고속 복사를 사용한다.
  - ArrayList 는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다. 
  - 반면, LinkedList 는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다 
  - ArrayList 의 경우 CAPACITY 를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다. 하지만 한번에 50%씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.

### hash 알고리즘
- index사용, 나머지 연산, 해시 충돌
- hashCode()
  - 문자열 같은 정보를 고유한 정수 값으로 바꿔준다
  - hashCode()를 재정의하면 필요한 모든 종류의 객체를 해시 자료 구조에 보관할 수 있다
  - 재정의 하지 않으면 논리적으로 동등성을 가지는 객체들도 다른 해시코드 값을 가지게 됨
- 해시 자료구조의 equals()와 hashCode()의 중요성
- Set의 주요 구현 클래스
  - HashSet : 순서 없는 빠른 저장소, O(1)
  - LinkedHashSet : 입력 순서를 기억하는 저장소, O(1), 약간의 메모리 더 사용
  - TreeSet : 자동으로 정렬되는 저장소, O(log n), 데이터가 정렬된 채로 입력되면 균형을 맞출 필요가 있음 (레드 블랙 트리 알고리즘 사용)
- Map과 Set
  - Map의 키는 중복을 허용하지 않고 순서를 보장하지 않는다는 점에서 Set과 매우 유사한 구조를 가진다.
  - 값(Value)은 단순히 키에 따라붙는 데이터로 볼 수 있다.
  - HashSet은 HashMap을, LinkedHashSet은 LinkedHashMap을, TreeSet은 TreeMap을 기반으로 구현

### 순회
- Iterable, Iterator
  - 컬렉션 프레임워크의 모든 자료 구조를 일관된 방법으로 순회할 수 있도록 함
  - Iterable 인터페이스
    - Iterator 의 구현체를 반환하도록 하는 메서드 존재 (iterator())
    - 컬렉션 인터페이스 보다 상위 인터페이스
  - Iterator 인터페이스
    - 순회할 요소 여부, 커서 이동
  - 모두 구현 시 for문 사용 가능
- Map의 경우엔 바로 순회시키지 못한다
  - 계층 구조가 다르다는 것 항상 인지
  - keySet(), values(), entrySet() 사용해서 가공 후 순회

### 정렬
- 직접 만든 객체를 정렬할 수 있게 기준을 정의 해 줄 필요가 있다
- 복잡한 정렬 알고리즘(예: Dual-Pivot QuickSort, TimSort) 몰라도 됨
- comparable, comparator
  - 객체의 기본 정렬 방법은 객체에 Comparable 를 구현해서 정의한다. 이렇게 하면 객체는 이름 그대로 비교할 수 있는 객체가 되고 기본 정렬 방법을 가진다
  - 기본 정렬 외에 다른 정렬 방법을 사용해야 하는 경우 비교자(Comparator)를 별도로 구현해서 정렬 메서드에 전달하면 된다. 이 경우 전달한 Comparator 가 항상 우선권을 가진다.
