<h4>불변</h4>

- 공유 참조와 사이드 이펙트
    - 참조값을 공유 하는 행위는 자바 문법적으로 올바른 행동이기 때문에 막을 수 없음 -> 변경에 의한 사이드 이펙트(변경 하고 싶지 않은 변수 까지 변경되는거)를 막고싶을 때 불변클래스가 필요
- 불변으로 설계하는 이유
    - 캐시 안전성
    - 멀티스레드 안전성
    - 엔티티의 값 타입
- String 특성
    - byte 배열에 저장되도록 바뀜
    - 불변으로 설계된 이유
        - 문자열 풀을 통해 메모리사용 등 최적화를 한다
        - 만약 String 내부의 값을 변경할 수 있다면, 기존에 문자열 풀에서 같은 문자를 참조하는 변수의 모든 문자가
          함께 변경되어 버리는 문제가 발생한다
    - StringBuilder를 직접 사용하는 것이 더 좋은 경우
        - 반복문에서 반복해서 문자를 연결할 때
        - 조건문을 통해 동적으로 문자열을 조합할 때
        - 복잡한 문자열의 특정 부분을 변경해야 할 때
        - 매우 긴 대용량 문자열을 다룰 때
        - 나머지 대부분의 경우는 최적화 되므로 + 연산 사용
- 유지보수 vs 최적화
    - 코드 변경 없이 성능 최적화를 하면 가장 좋겠지만, 성능 최적화는 대부분 단순함 보다는 복잡함을 요구하고, 더
      많은 코드들을 추가로 만들어야 한다.
    - 그런데 진짜
      문제는 최적화를 한다고 했지만 전체 애플리케이션의 성능 관점에서 보면 불필요한 최적화를 할 가능성이 있다
    - 특히 웹 애플리케이션의 경우 메모리 안에서 발생하는 연산 하나보다 네트워크 호출 한 번이 많게는 수십만배 더
      오래 걸린다.
    - 자바 메모리 내부에서 발생하는 연산을 수천번에서 한 번으로 줄이는 것 보다, 네트워크 호출 한 번
      을 더 줄이는 것이 더 효과적인 경우가 많다.
- 래퍼 클래스, 날짜와 시간 클래스는 불변 클래스 이다

<h4>열거</h4>

- 타입 안전 열거형 패턴
  - 상수들을 사용하여 코드 내에서 미리 정의된 값들의 집합

<h4>중첩 클래스</h4>

- 중첩 클래스를 사용하는 이유 
  - 논리적 그룹화
    - 특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우 해당 클래스 안에 포함하는 것이 논리
      적으로 더 그룹화 된다.
    - 패키지를 열었을 때 다른 곳에서 사용될 필요가 없는 중첩 클래스가 외부에 노출되지 않는
      장점도 있다.
  - 캡슐화
    - 중첩 클래스는 바깥 클래스의 private 멤버에 접근할 수 있다.
    - 이렇게 해서 둘을 긴밀하게 연결하고 불 필요한 public 메서드를 제거할 수 있다.
  - 정적 중첩 클래스
    - 구조상으론 사실 다른 클래스를 그냥 중첩해 둔 것일 뿐 둘은 아무런 관계가 없다
    - 그냥 클래스2개를 따로 만든것과 같다. private 접근 제어자에 접근할 수 있다는 정도 차이가 있음
  - 내부 클래스
    - 내부 클래스는 바깥 클래스의 인스턴스에 소속된다. 
    - 따라서 바깥 클래스의 인스턴스 정보를 알아야 생성할 수 있다. (바깥클래스의 인스턴스 참조.new 내부클래스())
    - 개념상 바깥 클래스의 인스턴스 내부에서 내부 클래스의 인스턴스가 생성
      - 실제로는 내부 인스턴스는 바깥 인스턴스의 참조를 보관
  - 지역 클래스 지역 변수 캡쳐
    - 지역 클래스를 통해 생성한 인스턴스가 지역 변수에 접근해야 하는데, 둘의 생명 주기가 다르기 때문에 인스턴스는 살아
      있지만, 지역 변수는 이미 제거된 상태일 수 있다
    - 이런 문제를 해결하기 위해 지역 클래스의 인스턴스를 생성하는 시점에 필요한 지역 변수를 복사해서 생성한 인
      스턴스에 함께 넣어둔다
    - 지역 클래스가 접근하는 지역 변수는 절대로 중간에 값이 변하면 안된다 -> final특성을 가지도록 설계 됨
  - 익명 클래스
    - 익명 클래스는 부모 클래스를 상속 받거나, 또는 인터페이스를 구현해야 한다
    - 지역 클래스가 일회성으로 사용되는 경우나 간단한 구현을 제공할 때 사용
    - 람다로 응용 됨 (매개변수로 메서드/코드 블럭 전달 하는 것 처럼)

<h4>예외 처리</h4>

- try catch finally
  - 정상 흐름과 예외 흐름을 분리해서, 코드를 읽기 쉽게 만든다.
  - 사용한 자원을 항상 반환할 수 있도록 보장
- 실무 예외 처리 방안
  - 처리할 수 없는 예외 & 체크드 예외의 부담 의 문제들로 예외 처리 지옥에 빠질 수 있음
  - 최근에는 런타임(언체크) 예외를 사용하여 throws를 사용하지 않더라도 자동으로 예외를 던지도록 하고, 개발자가 서비스 로직으로 처리하지 못하는 예외들을 다른곳에서 공통으로 처리함
  - 예외도 객체이므로 필요하면 instanceof 와 같이 예외 객체의 타입을 확인해서 별도의 추가 처리를 할 수 있
    다.
- try with resources
  - 리소스 누수 방지, 코드 간결성 및 가독성, 리소스의 스코프 범위 한정 효과, 조금 더 빠른 자원 해제